using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AdventOfCode {
    class Day07 {
        public static void Solve() {
            //SolvePart01();
           SolvePart02();
        }
        private static void SolvePart02() {
            int[] input;
            input = new int[] { 0, 1, 2, 3, 4 };
            String inputValueForMax = "";
            long result;
            long maxResult = Int64.MinValue;
            List<Day07State> states;
            for (int i = 56789; i <= 98765; i++) {
                //Console.WriteLine("i=" + i);
                String tmp; tmp = i.ToString(); int num; num = i;
                input = new int[] { 0, 0, 0, 0, 0 };
                for (int k = 4; k >= 0; k--) { input[k] = num - ((num / 10)* 10); num /= 10; }
                Boolean foundAllDigits; foundAllDigits = true;
                for (int k = 5; k < 10; k++) { if (!input.Contains(k)) { foundAllDigits = false; } }
                if (!foundAllDigits) { continue; }
                //              Console.WriteLine("Processing " + Convert.ToString(input));
                result = 0;
                int lastOutput = 0;
                Boolean firstPass = true;
                states = new List<Day07State>();
                for (int ii = 0; ii < 5; ii++) {
                    states.Add(new Day07State());
                    states.ElementAt<Day07State>(ii).op = (int[])Day07Data.day07Data.Clone();
                }
                Boolean keepGoing; keepGoing = true;
                while (keepGoing) {
                    for (int n = 0; n < 5; n++) {
                        if (firstPass) { states.ElementAt<Day07State>(n).input.Add(input[n]); } // Is it appended or dos it always go in the second position?
                        states.ElementAt<Day07State>(n).input.Add(lastOutput);
                        try {
                            lastOutput = Convert.ToInt32(states.ElementAt<Day07State>(n).ExecuteIntCodeComputer());
                            if (states.ElementAt<Day07State>(n).haltFound == true) {
                                if (n == 4) { // if we got this far we executed a code 99 in the computer on tht 5th amplifier.
                                    keepGoing = false;
                                } 
                            }
                        } catch (Exception ex) {
                            // The computer ran out of input and threw an exception.
//                            Console.WriteLine("Out of input");
                            keepGoing = true;
                        }
                    }
                    //if (done) { break; }
                    firstPass = false;
                }
                Console.WriteLine("last output = " + lastOutput + " for inputs of " + i.ToString());
                if (maxResult < lastOutput) { maxResult = lastOutput; inputValueForMax = i.ToString(); }
            }
            Console.WriteLine("Max result = " + maxResult + " for input of " + inputValueForMax);
        }
        
        private static void SolvePart01() { 
            int[] input;
            input = new int[] { 0, 1, 2, 3, 4 };
            String inputValueForMax = "";
            long result;
            long maxResult = Int64.MinValue;
            for (int i = 1234; i <= 43210; i++) {
                String tmp; tmp = i.ToString(); int num; num = i;
                input = new int[] { 0, 0, 0, 0, 0 };
                for (int k = 4; k >= 0; k--) { input[k] = num - ((num / 10)* 10); num /= 10; }
                Boolean foundAllDigits; foundAllDigits = true;
                for (int k = 0; k < 5; k++) { if (!input.Contains(k)) { foundAllDigits = false; } }
                if (!foundAllDigits) { continue; }
                //              Console.WriteLine("Processing " + Convert.ToString(input));
                result = 0;
                int[] p;
                int[] realInput = new int[2]; int lastOutput = 0;
                for (int n = 0; n < 5; n++) {
                    p = (int[])Day07Data.day07Data.Clone();
                    realInput[0] = input[n];
                    realInput[1] = lastOutput;
                    lastOutput = Convert.ToInt32(ExecuteIntCodeComputer(p, realInput)); // It only uses the first two inputs, but oh well.
                }
                Console.WriteLine("result = " + result + " for inputs of " + i.ToString());
                if (maxResult < lastOutput) { maxResult = lastOutput; inputValueForMax = i.ToString(); }
            }
            Console.WriteLine("Max result = " + maxResult + " for input of " + inputValueForMax);
        }
        /// <summary>
        /// This is lifted from Day 05 Part 02
        /// </summary>
        /// <param name="op"></param>
        /// <param name="input"></param>
        /// <returns>The output generated by the computer</returns>
        public static String ExecuteIntCodeComputer(int[] op, int[] input) {
            String output = "";
            int inputIdx = 0;
            int[] p = (int[])op.Clone();
            Boolean keepGoing = true;
            for (int i = 0; i < p.Length && keepGoing;) {
                int a, b, c;
                int[] parameterModes;
                parameterModes = ComputeParameterModes(p[i] / 100); // Parameter modes are stored in the digits after removing the op code digits
                switch (p[i] % 100) {               // The op code is in the rightmost 2 digits
                case 1:     // Add
                a = ComputeValue(parameterModes[2], p[i + 3], i + 3);
                b = p[ComputeValue(parameterModes[0], p[i + 1], i + 1)];
                c = p[ComputeValue(parameterModes[1], p[i + 2], i + 2)];
                //                    Console.WriteLine("Add: i = " + i + " " + p[i] + " " + p[i + 1] + " " + p[i + 2] + ", a = " + a + ", b = " + b + ", c = " + c);
                p[a] = b + c;
                i += 4;
                break;
                case 2:     // Multiply
                a = ComputeValue(parameterModes[2], p[i + 3], i + 3);
                b = p[ComputeValue(parameterModes[0], p[i + 1], i + 1)];
                c = p[ComputeValue(parameterModes[1], p[i + 2], i + 2)];
                //                    Console.WriteLine("Multiply: i = " + i + " " + p[i] + " " + p[i + 1] + " " + p[i + 2] + ", a = " + a + ", b = " + b + ", c = " + c);
                p[a] = b * c;
                i += 4;
                break;
                case 3:     // takes a single integer as input and saves it to the position given by its only parameter.
                a = ComputeValue(parameterModes[0], p[i + 1], i + 1);
                p[a] = input[inputIdx];
                Console.WriteLine("Reading input # " + inputIdx + " = " + p[a] + " ");
                inputIdx++;
                //                    Console.WriteLine("Save: i = " + i + " " + p[i] + " " + p[i + 1] + ", a = " + a);
                i += 2;
                break;
                case 4:     // outputs the value of its only parameter.
                a = ComputeValue(parameterModes[0], p[i + 1], i + 1);
                Console.Write("Output = " + p[a] + " ");
                output += Convert.ToString(p[a]);
                //                    Console.WriteLine("Output: i = " + i + " " + p[i] + " " + p[i + 1] + ", a = " + a);
                i += 2;
                break;
                case 5: // jump-if-true: if the first parameter is non-zero, it sets the instruction pointer to the value from the second parameter. Otherwise, it does nothing.
                b = p[ComputeValue(parameterModes[0], p[i + 1], i + 1)];
                c = p[ComputeValue(parameterModes[1], p[i + 2], i + 2)];
                if (b != 0) { i = c; } else { i += 3; }
                break;
                case 6: // jump-if-false: if the first parameter is zero, it sets the instruction pointer to the value from the second parameter. Otherwise, it does nothing
                b = p[ComputeValue(parameterModes[0], p[i + 1], i + 1)];
                c = p[ComputeValue(parameterModes[1], p[i + 2], i + 2)];
                if (b == 0) { i = c; } else { i += 3; }
                break;
                case 7: // less than: if the first parameter is less than the second parameter, it stores 1 in the position given by the third parameter. Otherwise, it stores 0.
                a = ComputeValue(parameterModes[2], p[i + 3], i + 3);
                b = p[ComputeValue(parameterModes[0], p[i + 1], i + 1)];
                c = p[ComputeValue(parameterModes[1], p[i + 2], i + 2)];
                if (b < c) { p[a] = 1; } else { p[a] = 0; }
                i += 4;
                break;
                case 8: // equals: if the first parameter is equal to the second parameter, it stores 1 in the position given by the third parameter. Otherwise, it stores 0.
                a = ComputeValue(parameterModes[2], p[i + 3], i + 3);
                b = p[ComputeValue(parameterModes[0], p[i + 1], i + 1)];
                c = p[ComputeValue(parameterModes[1], p[i + 2], i + 2)];
                if (b == c) { p[a] = 1; } else { p[a] = 0; }
                i += 4;
                break;

                case 99:    // Halt
                keepGoing = false;
                break;

                default:
                Console.WriteLine("SolveDay05Part01(): Invalid opcode at index " + i + " (" + p[i] + ")");
                i++;
                break;
                }
            }
            return output;
        }
        private static int[] ComputeParameterModes(int parameterCode) {
            int i = 0;
            int[] parameterModes = new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };     // 10 is arbitrary. 0 is the default mode. 
            while (parameterCode > 0) {
                parameterModes[i] = parameterCode - ((parameterCode / 10) * 10);
                i++;
                parameterCode /= 10;
            }
            return parameterModes;
        }
        private static int ComputeValue(int parameterMode, int value1, int value2) {
            int value = 0;
            switch (parameterMode) {
            case 0:     // position mode
            value = value1;
            break;
            case 1:     // immediate mode
            value = value2;
            break;
            case 2:
            throw new Exception("ComputeValue(): Invalid parameterMode: " + parameterMode);
            //break;
            }
            return value;
        }


    }
}
