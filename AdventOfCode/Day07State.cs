using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AdventOfCode {
    class Day07State {
        public int[] op;
        public int pointer;
        public int inputIdx;
        public List<int> input;
        public Boolean haltFound;
        public Boolean waitingForInput;
        public String output;
        public Day07State() { pointer = 0; input = new List<int>(); haltFound = false; waitingForInput = false; output = ""; }
        /// <summary>
        /// This is lifted from Day 05 Part 02
        /// </summary>
        /// <param name="op"></param>
        /// <param name="input"></param>
        /// <returns>The output generated by the computer</returns>
        public String ExecuteIntCodeComputer() {
            output = "";                    // Start over with new output because the last time we were in this machine we returned the previous output
            int i = pointer;
            Boolean keepGoing = true;
            while (keepGoing) {
//          for (int i = 0; i < op.Length && keepGoing;) {
                int a, b, c;
                int[] parameterModes;
                parameterModes = ComputeParameterModes(op[i] / 100); // Parameter modes are stored in the digits after removing the op code digits
                switch (op[i] % 100) {               // The op code is in the rightmost 2 digits
                case 1:     // Add
                    a = ComputeValue(parameterModes[2], op[i + 3], i + 3);
                    b = op[ComputeValue(parameterModes[0], op[i + 1], i + 1)];
                    c = op[ComputeValue(parameterModes[1], op[i + 2], i + 2)];
                    //                    Console.WriteLine("Add: i = " + i + " " + p[i] + " " + p[i + 1] + " " + p[i + 2] + ", a = " + a + ", b = " + b + ", c = " + c);
                    op[a] = b + c;
                    i += 4;
                    break;
                case 2:     // Multiply
                    a = ComputeValue(parameterModes[2], op[i + 3], i + 3);
                    b = op[ComputeValue(parameterModes[0], op[i + 1], i + 1)];
                    c = op[ComputeValue(parameterModes[1], op[i + 2], i + 2)];
                    //                    Console.WriteLine("Multiply: i = " + i + " " + p[i] + " " + p[i + 1] + " " + p[i + 2] + ", a = " + a + ", b = " + b + ", c = " + c);
                    op[a] = b * c;
                    i += 4;
                    break;
                case 3:     // takes a single integer as input and saves it to the position given by its only parameter.
                    int tmp = -1;
                    waitingForInput = false;
                    try {tmp = input.ElementAt<int>(inputIdx); } catch(Exception ex) { keepGoing = false; waitingForInput = true; }
                    if (keepGoing) { a = ComputeValue(parameterModes[0], op[i + 1], i + 1); op[a] = tmp; inputIdx++; i += 2; }
                    //Console.WriteLine("Reading input # " + inputIdx + " = " + p[a] + " ");
                    break;
                case 4:     // outputs the value of its only parameter.
                    a = ComputeValue(parameterModes[0], op[i + 1], i + 1);
                    //Console.Write("Output = " + op[a] + " ");
                    output += Convert.ToString(op[a]);
                    //                    Console.WriteLine("Output: i = " + i + " " + p[i] + " " + p[i + 1] + ", a = " + a);
                    i += 2;
                    break;
                case 5: // jump-if-true: if the first parameter is non-zero, it sets the instruction pointer to the value from the second parameter. Otherwise, it does nothing.
                    b = op[ComputeValue(parameterModes[0], op[i + 1], i + 1)];
                    c = op[ComputeValue(parameterModes[1], op[i + 2], i + 2)];
                    if (b != 0) { i = c; } else { i += 3; }
                    break;
                case 6: // jump-if-false: if the first parameter is zero, it sets the instruction pointer to the value from the second parameter. Otherwise, it does nothing
                    b = op[ComputeValue(parameterModes[0], op[i + 1], i + 1)];
                    c = op[ComputeValue(parameterModes[1], op[i + 2], i + 2)];
                    if (b == 0) { i = c; } else { i += 3; }
                    break;
                case 7: // less than: if the first parameter is less than the second parameter, it stores 1 in the position given by the third parameter. Otherwise, it stores 0.
                    a = ComputeValue(parameterModes[2], op[i + 3], i + 3);
                    b = op[ComputeValue(parameterModes[0], op[i + 1], i + 1)];
                    c = op[ComputeValue(parameterModes[1], op[i + 2], i + 2)];
                    if (b < c) { op[a] = 1; } else { op[a] = 0; }
                    i += 4;
                    break;
                case 8: // equals: if the first parameter is equal to the second parameter, it stores 1 in the position given by the third parameter. Otherwise, it stores 0.
                    a = ComputeValue(parameterModes[2], op[i + 3], i + 3);
                    b = op[ComputeValue(parameterModes[0], op[i + 1], i + 1)];
                    c = op[ComputeValue(parameterModes[1], op[i + 2], i + 2)];
                    if (b == c) { op[a] = 1; } else { op[a] = 0; }
                    i += 4;
                    break;

                case 99:    // Halt
                    keepGoing = false;
                    haltFound = true;

                    break;

                default:
                    Console.WriteLine("SolveDay05Part01(): Invalid opcode at index " + i + " (" + op[i] + ")");
                    i++;
                    break;
                }
            }
            pointer = i;    // Preserve the instruction pointer
            return output;
        }
        private static int[] ComputeParameterModes(int parameterCode) {
            int i = 0;
            int[] parameterModes = new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };     // 10 is arbitrary. 0 is the default mode. 
            while (parameterCode > 0) {
                parameterModes[i] = parameterCode - ((parameterCode / 10) * 10);
                i++;
                parameterCode /= 10;
            }
            return parameterModes;
        }
        private static int ComputeValue(int parameterMode, int value1, int value2) {
            int value = 0;
            switch (parameterMode) {
            case 0:     // position mode
            value = value1;
            break;
            case 1:     // immediate mode
            value = value2;
            break;
            case 2:
            throw new Exception("ComputeValue(): Invalid parameterMode: " + parameterMode);
            //break;
            }
            return value;
        }

    }
}
